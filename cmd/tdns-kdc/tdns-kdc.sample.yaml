# TDNS Key Distribution Center (KDC) Configuration
# This is a sample configuration file for tdns-kdc

service:
   name:                TDNS-KDC
   verbose:             true
   debug:               false   # Set to true for detailed debugging output

apiserver:
   usetls:              true
   addresses:           [ 127.0.0.1:8991 ]
   apikey:              change-this-to-a-secure-random-key
   certfile:            /etc/tdns/certs/localhost.crt
   keyfile:             /etc/tdns/certs/localhost.key

# DNS engine configuration for handling KMREQ and KMCTRL queries
dnsengine:
   addresses:           [ 127.0.0.1:5354, '[::1]:5354' ]  # Addresses to listen on for DNS queries
   transports:          [ do53 ]  # Transport protocols: do53, dot, doh, doq
   certfile:            /etc/tdns/certs/localhost.crt  # Required for dot, doh, doq
   keyfile:             /etc/tdns/certs/localhost.key  # Required for dot, doh, doq

# KDC-specific configuration
kdc:
   # Database configuration
   # Type: "sqlite" or "mariadb"
   # For SQLite: dsn is the file path (e.g., "/var/lib/tdns/kdc.db")
   #   Example: type: sqlite
   #            dsn: "/var/lib/tdns/kdc.db"
   # For MariaDB: dsn is "user:password@tcp(host:port)/dbname"
   #   Example: type: mariadb
   #            dsn: "kdcuser:password@tcp(localhost:3306)/tdns_kdc"
   database:
      type:               sqlite   # or "mariadb"
      dsn:                "/var/lib/tdns/kdc.db"   # SQLite file path, or MariaDB DSN
   
   # Control zone where KMCTRL records are published
   # This zone must be served by the KDC and will contain control records
   # for edge nodes to discover the KDC and request keys
   control_zone:        "kdc.example.com."
   
   # Default DNSSEC algorithm for generated keys
   # Common values: 15 (ED25519), 13 (ECDSAP256SHA256), 8 (RSASHA256)
   default_algorithm:    15   # ED25519
   
   # How often to rotate ZSKs (Zone Signing Keys)
   # Format: Go duration (e.g., "720h" = 30 days, "168h" = 7 days)
   key_rotation_interval: 720h   # 30 days
   
   # Number of standby ZSKs to maintain for rapid rollover
   # When a key is compromised, a standby key can be activated immediately
   standby_key_count:    2
   
   # Key state transition timing configuration:
   
   # publish_time: Time a key must remain in 'published' state before automatically
   # transitioning to 'standby'. This allows old cached DNSKEY RRsets to expire
   # and ensures the key is widely available before it becomes available for distribution.
   # Format: Go duration string (e.g., "24h" = 24 hours, "168h" = 7 days, "48h" = 2 days)
   # The KeyStateWorker background process checks every minute and transitions keys
   # that have been published for at least this duration.
   publish_time:         24h   # 24 hours
   
   # retire_time: Time a key must remain in 'retired' state before automatically
   # transitioning to 'removed'. This allows all RRSIGs signed by the retired key
   # to expire, ensuring the key is no longer needed in the DNSKEY RRset.
   # Format: Go duration string (e.g., "30d" = 30 days, "720h" = 30 days, "14d" = 14 days)
   # The KeyStateWorker background process checks every minute and transitions keys
   # that have been retired for at least this duration.
   retire_time:          30d   # 30 days
   
   # distribution_ttl: Time-to-live for key distributions (replay protection)
   # Distributions include a timestamp in the MANIFEST/CHUNK metadata, and KRS validates
   # that distributions are not older than this TTL. This prevents replay attacks where
   # an old distribution is reused. The timestamp is protected by DNSSEC (RRSIG on
   # MANIFEST/CHUNK), providing integrity protection.
   # Format: Go duration string (e.g., "5m" = 5 minutes, "10m" = 10 minutes)
   # Default: 5 minutes (same as TSIG signatures). Set to 0 to disable TTL validation.
   distribution_ttl:     5m    # 5 minutes (default, like TSIG)
   
   # chunk_max_size: Maximum RDATA size per OLDCHUNK/CHUNK record in bytes
   # This controls how large each chunk can be when distributing encrypted keys
   # via the CHUNK RRtype. Larger values mean fewer chunks but larger DNS messages.
   # Default: 60000 (60KB). Maximum practical size is ~64KB due to DNS message limits.
   # For testing with small chunk sizes, set this to a smaller value (e.g., 1000).
   chunk_max_size:   60000   # 60KB (default)
   
   # manifest_json_format: Controls whether CHUNK manifest chunks are displayed as JSON or base64
   # When true (default): Manifest chunks are displayed as clear text JSON in DNS responses
   # When false: Manifest chunks are displayed as base64-encoded strings
   # Note: This affects the String() representation for display/debugging. The wire format
   # (binary RDATA) is always the same. Both formats are valid and can be parsed by KRS.
   # Default: true (JSON format for better readability)
   # This is currently a code-level setting (core.ManifestJSONFormat) and not yet
   # configurable via YAML. Set programmatically if needed.
   # manifest_json_format: true   # JSON format (default)

   # KDC HPKE private key (X25519, 32 bytes)
   # Required for encryption of HPKE-based enrollments and key distributions.
   # Generate with: kdc-cli keys generate --hpke --hpke-outfile <path>
   kdc_hpke_priv_key: /etc/tdns/kdc/kdc.hpke.privatekey

   # KDC HPKE signing key (P-256 ECDSA)
   # Optional: Required only for signed HPKE distributions (JWS(JWE)).
   # HPKE uses X25519 for encryption, but P-256 ECDSA for signing.
   # Without this key, HPKE distributions will be unsigned (encryption only, no signature).
   # Generate with: kdc-cli keys generate --hpke-signing --hpke-signing-outfile <path>
   kdc_hpke_signing_key: /etc/tdns/kdc/kdc.hpke.signing.privatekey

   # KDC JOSE private key (P-256 ECDSA)
   # Optional: Only required if you need JOSE-capable enrollments or clients.
   # JOSE uses P-256 for both encryption (ECDH-ES) and signing (ECDSA).
   # Generate with: kdc-cli keys generate --jose --jose-outfile <path>
   kdc_jose_priv_key: /etc/tdns/kdc/kdc.jose.privatekey

   # use_crypto_v2: Enable crypto abstraction layer (v2) for multi-backend support
   # When true: Supports both HPKE and JOSE backends via unified crypto interface
   # When false: Uses direct HPKE implementation (v1, backward compatible)
   # Default: false (uses v1 for backward compatibility)
   use_crypto_v2: true

log:
   file:                /var/log/tdns/tdns-kdc.log

common:
   command:             /usr/local/libexec/tdns-kdc
   debug:               false
   verbose:             true

